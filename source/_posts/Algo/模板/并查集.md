/*
*1562. 查找大小为 M 的最新分组
给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。
在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1 。
给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。
返回存在长度 恰好 为 m 的 一组 1  的最后步骤。如果不存在这样的步骤，请返回 -1 。

输入：arr = [3,5,1,2,4], m = 1
输出：4
解释：
步骤 1："00100"，由 1 构成的组：["1"]
步骤 2："00101"，由 1 构成的组：["1", "1"]
步骤 3："10101"，由 1 构成的组：["1", "1", "1"]
步骤 4："11101"，由 1 构成的组：["111", "1"]
步骤 5："11111"，由 1 构成的组：["11111"]
存在长度为 1 的一组 1 的最后步骤是步骤 4 。
*/

```cpp

#include <climits>
#include <functional>
#include <iostream>
#include <queue>
#include <vector>
using namespace std;


class Solution {
public:
    int findLatestStep(vector<int> &arr, int m) {
        int n = arr.size();
        // fa[i]表示i的父节点
        vector<int> fa(n + 2);
        // l[i]表示以i结尾的连续1的长度
        vector<int> l(n + 2);

        // 初始化并查集
        for (int i = 0; i <= n + 1; i++) { fa[i] = i; }

        // 并查集查找
        function<int(int)> find = [&](int x) -> int {
            if (fa[x] != x) { fa[x] = find(fa[x]); }
            return fa[x];
        };

        int ans = -1;  // 记录最后一次出现长度为m的连续1的步骤
        int cnt = 0;   // 记录当前长度为m的连续1的个数

        // 遍历每一步操作
        for (int i = 0; i < n; i++) {
            int pos = arr[i];
            // 找到当前位置右边的连续1的根节点
            int to = find(pos + 1);
            // 将当前位置合并到右边的连续1中
            fa[pos] = to;

            // 如果合并前的长度是m，需要减少计数
            if (l[to] == m) cnt--;
            if (l[pos] == m) cnt--;

            // 更新长度：当前位置的长度加上右边连续1的长度再加1
            l[to] += l[pos] + 1;

            // 如果合并后的长度是m，增加计数
            if (l[to] == m) cnt++;

            // 如果存在长度为m的连续1，更新答案
            if (cnt > 0) { ans = i + 1; }
        }

        return ans;
    }
};

int main() {
    vector<int> arr1 = {3, 5, 1, 2, 4};
    int         m1   = 1;
    Solution    solution;
    cout << "Example 1 output: " << solution.findLatestStep(arr1, m1) << endl;

    vector<int> arr2 = {3, 1, 5, 4, 2};
    int         m2   = 2;
    cout << "Example 2 output: " << solution.findLatestStep(arr2, m2) << endl;

    vector<int> arr3 = {1};
    int         m3   = 1;
    cout << "Example 3 output: " << solution.findLatestStep(arr3, m3) << endl;

    vector<int> arr4 = {2, 1};
    int         m4   = 2;
    cout << "Example 4 output: " << solution.findLatestStep(arr4, m4) << endl;
}
