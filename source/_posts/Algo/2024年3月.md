# 


# 3月20日机试
## 1. 火车

```cpp
```cpp
#include <climits>

#include <cmath>

#include <iostream>

#include <vector>

using namespace std;

/*

24年3月1题：

  

一列具有  个座位的火车，从起点到终点共停靠  个站点，站点编号从到。发车前有名乘客预定了座位，因为预定数量可能超出座位数，为了保证效率最大化，请计算如何分配才能是座位利用率最大，并输出最大的座位利用数。

  

说明:座位利用数定义为每个座位被使用的站数。例如有两个座位，第一个座位从第到站有人坐(表示从站上车，站下车，第站不占座，所以利用率是)，第二个座位从第到站有人坐，则座位利用率为。乘客在某站下车后，其他乘客从这一站就可以开始使用这个座位;

  

无需考虑乘客需要更换座位的问题，保证任意时刻列车上乘客数量不超过即可

  
  

输入2 11 4

[0,1]

[1 9]

[0 10]

[3 8]

输出19

说明选择前三位乘客可以使座位利用率最大:。若选择后两位乘客，则利用率为。若选择全部四位乘客，则第到站车上存在名乘客，超出列车座位数。

  

遍历 2^x 种情况

*/

  

int main() {

    int m, n; // m个座位，n个站点

    cin >> m >> n;

    int x; // x行条目

    cin >> x;

  

    vector<pair<int, int>> pass(x); // 存储每个乘客的上下车站点

  

    for (int i = 0; i < x; i++) {

        cin >> pass[i].first >> pass[i].second; // [a,b)

    }

  

    int ans = 0;

    // 枚举所有乘客是否上车的情况

    for (int mask = 0; mask < (1 << x); mask++) {

        int         val = 0;    //乘客乘坐的站数和

        vector<int> mans(n, 0); // 每个站点车上的客数

        for (int i = 0; i < x; i++) {

            if (mask & (1 << i)) { // i号乘客上车，mans[a,b)++

                val += pass[i].second - pass[i].first;

                for (int k = pass[i].first; k < pass[i].second; k++)

                    mans[k]++;

            }

        }

  

        bool flag = true; // 对于每一个mask，任意站点的人数不能超n

        for (int i = 0; i < n; i++) {

            if (mans[i] > m)

                flag = false;

        }

  

        if (flag)

            ans = max(ans, val);

    }

  

    cout << ans << endl;

    return 0;

}
```



## 2. 积木塔
小明在玩积木塔游戏。他有一系列的积木块，每块上标有一个正整数。

他按照特定的规则堆积这些积木块：
添加新的积木时，如果这块积木上的数字与塔顶的积木数字相同，他会取下两块积木，将上面的数字相加后，然后放回一块新的积木。

此外，如果塔顶的积木数字等于下面连续几块积木数字之和，他同样会取下这些积木，进行相同的操作。
如果这两个条件都不符合，他就会简单地将新的积木放在塔顶。现在，小明按照一定顺序添加了一系列的积木，请你计算游戏结束后积木塔各块上的数字。

```cpp
#include <algorithm>

#include <climits>

#include <cmath>

#include <iostream>

#include <map>

#include <queue>

#include <sstream>

#include <stack>

using namespace std;

/*

小明在玩积木塔游戏。他有一系列的积木块，每块上标有一个正整数。他按照特定的规则堆积这些积木块：

每次小明添加一块新的积木时，

如果这块积木上的数字与塔顶的积木数字相同，他会取下两块积木，将上面的数字相加后，然后放回一块新的积木。\

此外，如果塔顶的积木数字等于下面连续几块积木数字之和，他同样会取下这些积木，进行相同的操作。如果这两个条件都不符合，他就会简单地将新的积木放在塔顶。现在，小明按照一定顺序添加了一系列的积木，请你计算游戏结束后积木塔各块上的数字。

55 66 121 5 5

242 10

  

print (10 242)

  
  

*/

  

int main() {

    int         num;

    vector<int> st;

    while (cin >> num) {

        st.push_back(num);

        // printf("%d ", num);

  

        while (st.size() > 1) {

            int  top   = st.size() - 1; //topId

            bool flag1 = false;

            bool flag2 = false;

  

            if (st[top - 1] == st[top]) {

                flag1 = true;

                st.pop_back();

                top--;

                st[top] = st[top] * 2;

            } else {

                int sum = 0;

                for (int i = top - 1; i >= 0; i--) {

                    sum += st[i];

                    if (sum == st[top]) {

                        flag2 = true;

                        while (st.size() > i + 1) st.pop_back();

                        st[i] = st[top];

                        st.push_back(st[top]);

                        top = i + 1;

                        break;

                    }

                }

            }

  

            if (!flag1 && !flag2) break;

        }

  

        if (cin.get() == '\n') break;

    }

  

    // print

    while (st.size() > 1) {

        cout << st.back() << " ";

        st.pop_back();

    }

    cout << st.back();

    st.pop_back();

}
```



## 3. 依赖图找唯一循环依赖

```cpp
#include <iostream>

#include <vector>

using namespace std;

/*

题目描述给定一组元素，及其依赖关系，一个元素可以依赖于多个元素(不包括自己，被依赖元素不会重复)一个元素也可被多个元素依赖。假定总是存在**唯一的循环依赖**，请输出该循环依赖。

  

输入描述第一行一个正整数，表示依赖关系的个数。接下来每一行表示一个依赖关系，是由空格分割的多个正整数，第一个数表示后面有个元素，第二个数为元素编号，后面多个数为依赖的元素编号，任意元素满足1 <= 元素编号 <= 10000

  

输出描述一串数字，代表这个循环依赖，从最小元素编号开始，按照依赖关系依次输出，以最小元素结束。样例输入

  

3

3 1 2 5

3 2 3 4

2 3 1

输出1 2 3 1

  

说明元素1依赖于2，5元素2依赖于3，4元素3依赖于1

  

*/

int main() {

    int m;

    cin >> m;

    vector<vector<int>> graph(m + 1);

  

    // 构建图

    for (int i = 1; i <= m; i++) {

        int n, from;

        cin >> n >> from;

        for (int j = 0; j < n - 1; j++) {

            int to;

            cin >> to;

            graph[from].push_back(to);

        }

    }

  

    vector<bool> visited(m + 1, false); // 全局访问标记

    vector<bool> inStack(m + 1, false); // 当前路径访问标记

    vector<int>  cycle; // 存储找到的环

    bool         found = false; // 是否找到环

  

    // DFS找环

    auto dfs = [&](auto &&dfs, int curr, vector<int> &path) -> void {

        if (found) return;

  

        visited[curr] = true;

        inStack[curr] = true;

        path.push_back(curr);

  

        for (int next : graph[curr]) {

            if (found) return;

            if (!visited[next]) {

                dfs(dfs, next, path);

            } else if (inStack[next]) {

                // 找到环，记录环上的节点

                found     = true;

                int start = 0;

                while (start < path.size() && path[start] != next) { start++; }

                cycle = vector<int>(path.begin() + start);

                return;

            }

        }

  

        inStack[curr] = false;

        path.pop_back();

    };

  

    // 从每个未访问的节点开始DFS

    vector<int> path;

    for (int i = 1; i <= m && !found; i++) {

        if (!visited[i]) {

            path.clear();

            dfs(dfs, i, path);

        }

    }

  

    // 找到环中最小的元素位置

    if (!cycle.empty()) {

        int min_idx = 0;

        for (int i = 1; i < cycle.size(); i++) {

            if (cycle[i] < cycle[min_idx]) { min_idx = i; }

        }

  

        // 从最小元素开始输出环

        for (int i = 0; i < cycle.size(); i++) { cout << cycle[(i + min_idx) % cycle.size()] << " "; }

        cout << cycle[min_idx] << endl;

    }

  

    return 0;

}
```




